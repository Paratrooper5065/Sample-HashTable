# Sample-HashTable (Dispel and That Spell)
Sample Code For Review

# Project Description
This project is basically a database or a collection of data. These data are stored in their own tables and in a specific order. I have used different types of hashing and collision strategies in this program. This helps me to recover or retrieve data later. Hashing is widely spread, even in colleges, business, offices or universities. We can think our student ID, employee ID or transaction ID as key values. These are different for every individual, thus helping whoever is looking at the data to retain and manage information. This program can also help shopping markets keep track of their products, customers and other important information.

# Data Structure
For data structure I used class, vectors and hash tables. I used Class to create multiple objects that have their own private and public functions. The private functions are the ones that can only be used by themselves, however I had large public functions so that I can link it with other classes as well, to make my program shorter and easier to navigate. Most of the accessors and mutators were public functions. I used both string and integer types depending on the area of interest. For example, I used integer to keep track of the size, number of rows and schemes. Likewise, I used string to keep track of table, tuple, scheme names.
I was debating between weather to define the table as vectors or arrays. However, after my brainstorming session, I ended up using vectors since they are pretty much big size of arrays. And it is always easier to “push_back”, “pop_back” and “erase” in vectors, which is actually a necessity for this project.
One of my challenges was to set the width of the output. I made a function that keeps track of the longest value and then uses it as the width+5 characters. In this way, my output is not all over the places and are decent to look at. It is also easier to navigate and find stuffs you are looking for. I used iomanip header to run this.
Another new function that I used was stoi. This basically interprets as “string to integer”, this was helpful, especially for hashing. Since I used stoi, this program cannot compile using regular “g++ *.cpp”, instead it needs “g++ -std=c++11 *.cpp” (c++ 11 version). I have three tables: “spells” , “items” and “customers” that stores respective information. For three tables, I used three different types of hashing and its own collision strategies.
For spells table, I used multiplicative string hash as the key for it was “name” which is a string type. It would have been really difficult if I used any other type of hashing function for this. As collision strategy, I used quadratic probing.
Both items and customers tables have ID as its key, which is an integer type. Here, I have used “stoi” to save the key as an integer for further calculations. For items table, I used Mid Square Hashing (Base 10) and as collision strategy, I used double hashing. For customers table, I used Modulo Hashing and as collision strategy, I used linear probing. Linear probing just checks the next bucket in case there is a collision.
My table size for all three tables are hundred, in other words there are hundred buckets in each table. The data in all these three tables try to fit according to its hashing function. In case of
collision, it redirects its path as the respective collision strategy. After going through hundred loops, the program gives out a friendly error message to the user saying it can add the tuples.
I also have a temporary variable that check whether the bucket is full or not. This is how the program knows when to use collision strategy and also useful for other functions like insert, update, delete and select.
I made modulo hashing, direct hashing, midsqaure hashing and multiplicative string hashing functions for my program. I have two midsquare as one of them I wanted to use it as base 2 but I was not confident with that one.
I had used direct hashing for the customer table for milestone, however the program resulted into a segmentation dump since it couldn’t take in values that had high key value. So, I changed it to modulo hashing for my final submission, just to be safe.
I have four .cpp files (main.cpp, collection.cpp, table.cpp and line.cpp) and three .h files(collection.h, table.h and line.h).

# Program Functionality
The walk through of my program is as follows:
My main.cpp file asks the user to input a filename which contains a list of instructions. The lines will have filename first and the table name later separated by a blank space. For example, if the first line has “spells.txt spells”, my program will open the “spells.txt” text file and save the information under “spells” table. In each of these text files, the first line will have the key name, second line will have the tuples each separated by a comma (,) and the rest of the lines would have information separated by ‘|’. The readdata function will take it to the “collection.cpp” file where the key, schemes and tablename. All these are retained by the “getline” command. I have a while loop where it compares the tablename and sends it to the respective tuple where it adds it to the database.
The information of spells, items and customers are saved using their respective hashing and collision strategies as mentioned above. If the bucket is empty, the data is stored in that bucket else the respective collision strategy is used to fill up the request.
Apart from filling up the table, there are also several instructions like “DISPLAY”, “INSERT” , “UPDATE” , “SELECT” , “DELETE” and “WRITE”.
The display function calls “printdata” which prints data from all of the tables in the screen. This function also utilizes the property to determine longest character to set the field width.
The insert, update, select and delete functions go to three different functions related to the tables respectively, where (0 = spells table, 1 = items table & 2 = customers table).
The insert function reads the table name and the information, that directs it to the respective table. Then the hash functions and collision strategies of the respective tables check whether the key is present or not. If it is already there, the user is returned with a friendly error message, if not the new data is inserted in the empty bucket.
The update function reads the table name and the information, that directs it to the respective table. Then the hash functions and collision strategies of the respective tables check whether the key is present or not. If the key is present, it deletes the existing data and replaces with the new data. If the key is not present, the user is returned with a friendly error message.
The select function reads the table name and the information, that directs it to the respective table. First of all the function checks for the “*” which is a free pass, if it finds a “*” it will use secondary index to find the data. If not, the hash functions and collision strategies of the
respective tables check whether the key is present or not. Whenever it finds the data that matches the criteria, it returns with the value. If the information is not found, user is returned with a friendly error message.
The delete function reads the table name and the information, that directs it to the respective table. First of all the function checks for the “*” which is a free pass, if it finds a “*” it will use secondary index to find the data. If not, the hash functions and collision strategies of the respective tables check whether the key is present or not. Whenever it finds the data that matches the criteria, the data is removed and temporary variable is set to 0, which now indicates that the bucket is empty. If the information is not found, user is returned with a friendly error message.
The write function writes all the table information in three different text files “spellswritefile.txt” , “itemswritefile.txt” and “customerswritefile.txt” for spells, items and customers respectively.
